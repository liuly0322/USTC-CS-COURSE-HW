# H15-2 代码优化

PB20000180 刘良宇

## 9.3

对图9.32的流图，计算：

(a) 为到达–定值分析，计算每个块的 gen、kill、IN 和 OUT 集合。 

|      |  GEN  |  KILL   |       IN        |      OUT      |
| :--: | :---: | :-----: | :-------------: | :-----------: |
|  B1  |  1,2  | 8,10,11 |        ∅        |      1,2      |
|  B2  |  3,4  |   5,6   |  1,2,3,4,5,8,9  |  1,2,3,4,8,9  |
|  B3  |   5   |   4,6   | 1,2,3,4,6,7,8,9 | 1,2,3,5,7,8,9 |
|  B4  |  6,7  |  4,5,9  |  1,2,3,5,7,8,9  |  1,2,3,6,7,8  |
|  B5  |  8,9  | 2,7,11  | 1,2,3,4,5,7,8,9 |  1,3,4,5,8,9  |
|  B6  | 10,11 |  1,2,8  |   1,3,4,5,8,9   | 3,4,5,9,10,11 |

(b) 为可用表达式分析，计算每个块的 e_gen、e_kill、IN 和 OUT 集合。

这里不考虑常量表达式：

|      |  e_gen   |    e_kill     |    IN    |   OUT    |
| :--: | :------: | :-----------: | :------: | :------: |
|  B1  |    ∅     | a+b, c-a, a-d |    ∅     |    ∅     |
|  B2  | a+b, c-a |   c-a, a-d    |    ∅     | a+b, c-a |
|  B3  |    ∅     |      a-d      | a+b, c-a | a+b, c-a |
|  B4  |   a+b    |      a-d      | a+b, c-a | a+b, c-a |
|  B5  |   c-a    |      a+b      | a+b, c-a |   c-a    |
|  B6  |   a-d    | a+b, c-a, a-d |   c-a    |   a-d    |

(c) 为活跃变量分析，计算每个块的 def、use、IN 和 OUT 集合。

|      |  USE  | DEF  |    IN     |    OUT    |
| :--: | :---: | :--: | :-------: | :-------: |
|  B1  |   ∅   | a,b  |     e     |   a,b,e   |
|  B2  |  a,b  | c,d  |   a,b,e   | a,b,c,d,e |
|  B3  |  b,d  |  d   | a,b,c,d,e | a,b,c,d,e |
|  B4  | a,b,e | d,e  |  a,b,c,e  | a,b,c,d,e |
|  B5  | a,b,c | b,e  |  a,b,c,d  |  a,b,d,e  |
|  B6  |  b,d  | a,b  |    b,d    |     ∅     |

## 9.31

> 下面的 C 程序分别经非优化编译和 2 级以上（含 2 级，如命令行选项 `-O2`）的优化编译后，生成的两个目标程序运行时的表现不同。
>请回答它们运行时的表现有何不同，并说明原因。
> ```c
> int f(int g()) {
>      return g(g);
> }
> main() {
>      f(f);
> }
> ```

- 非优化编译（`gcc (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0`，编译命令 `gcc test.c -o test`）。

  结果：报告段错误，退出（栈溢出）。

- `-Ofast` 优化。

  结果：不退出（死循环）。

原因：对比二者编译出的汇编文件，会发现前者每次直接进行函数调用，但后者的 f 函数：

```asm
f:
.LFB0:
        .cfi_startproc
        endbr64
        di
        jmp     *%rdi       ; 用跳转优化了尾调用
        .cfi_endproc
.LFE0:
        .size   f, .-f
        .section        .text.startup,"ax",@progbits
        .p2align 4
        .globl  main
        .type   main, @function
```

可以发现，由于源代码中，`f` 函数最后进行的是一个尾调用，也就是控制链上原 `f` 的活动记录在调用后无用（`g(g)` 可以直接返回给调用 `f` 的函数，而不需要先返回给 `f`），所以此时并不需要在调用栈上新建帧栈，只需要直接利用当前帧栈即可。表现出来结果就是栈的深度不会随着递归深度的增加而增加，因此不会栈溢出。