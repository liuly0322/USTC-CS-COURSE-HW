# H15-2 代码优化

PB20000180 刘良宇

## 9.3

对图9.32的流图，计算：

(a) 为到达–定值分析，计算每个块的 gen、kill、IN 和 OUT 集合。 



(b) 为可用表达式分析，计算每个块的 e_gen、e_kill、IN 和 OUT 集合。



(c) 为活跃变量分析，计算每个块的 def、use、IN 和 OUT 集合。



## 9.31

> 下面的 C 程序分别经非优化编译和 2 级以上（含 2 级，如命令行选项 `-O2`）的优化编译后，生成的两个目标程序运行时的表现不同。
>请回答它们运行时的表现有何不同，并说明原因。
> ```c
> int f(int g()) {
>      return g(g);
> }
> main() {
>      f(f);
> }
> ```

- 非优化编译（`gcc (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0`，编译命令 `gcc test.c -o test`）。

  结果：报告段错误，退出（栈溢出）。

- `-Ofast` 优化。

  结果：不退出（死循环）。

原因：对比二者编译出的汇编文件，会发现前者每次直接进行函数调用，但后者的 f 函数：

```asm
f:
.LFB0:
        .cfi_startproc
        endbr64
        di
        jmp     *%rdi       ; 用跳转优化了尾调用
        .cfi_endproc
.LFE0:
        .size   f, .-f
        .section        .text.startup,"ax",@progbits
        .p2align 4
        .globl  main
        .type   main, @function
```

可以发现，由于源代码中，`f` 函数最后进行的是一个尾调用，也就是控制链上原 `f` 的活动记录在调用后无用（`g(g)` 可以直接返回给调用 `f` 的函数，而不需要先返回给 `f`），所以此时并不需要在调用栈上新建帧栈，只需要直接利用当前帧栈即可。表现出来结果就是栈的深度不会随着递归深度的增加而增加，因此不会栈溢出。