# H9 类型检查 1

PB20000180 刘良宇

## 变量 a 的类型表达式

1. `int a[][3];`

   $pointer(array(3, integer))$

2. `int *a[3];`

   $array(3,pointer(integer))$

3. `int (*a)[3];`

   $pointer(array(3, integer))$

4. `int *(*a)[3];`

   $pointer(array(3, pointer(integer)))$

5. `int **a[3];`

   $array(3,pointer(pointer(integer)))$

6. `int *(*a[3])[2];`

   $array(3, pointer(array(2, pointer(integer))))$

## 翻译方案

$$
\begin{align*}
P &\rarr D; E\\
D &\rarr D; D\ |\ id : T\\
T &\rarr list\ of\ T\ |\ char\ |\ integer\\
E &\rarr (L)\ |\ literal\ |\ num\ |\ id\ |\ nil\\
L &\rarr E, L\ |\ E\\
\end{align*}
$$

对应翻译方案：

$$
\begin{align*}
P &\rarr D; E\\
D &\rarr D; D\\
D &\rarr id : T &\{addtype(id.entry,\ T.type)\}\\
T &\rarr list\ of\ T_1 &\{T.type= list(T_1.type)\}\\
T &\rarr char &\{T.type=char\} \\
T &\rarr integer &\{T.type=integer\}\\
E &\rarr (L) &\{E.type = list(L.type)\} \\
E &\rarr literal &\{E.type=pointer(char)\}\\
E &\rarr num &\{E.type=integer\} \\
E &\rarr id&\{E.type=lookup(id.entry)\}\\
E &\rarr nil&\{E.type=list(void)\}\\
L &\rarr E, L_1 &\{L.type = (E.type == L_1.type)? E.type : error\}\\
L &\rarr E &\{L.type=E.type\} \\
\end{align*}
$$

## 拓展类型检查

$$
\begin{align*}
  T &\rarr record\ fields\ end & \{T.type = fields.type\} \\
  fields &\rarr fields_1; field & \{fields.type = fields_1.type \times field.type\} \\
  fields &\rarr field & \{fields.type=field.type\} \\
  field &\rarr id : T &\{field.type=record(id:T)\}\\
  E &\rarr E.id &\{E.type.containsKey(id)? E.type[id]:error\}\\
\end{align*}
$$

这里假定 $record$ 类型有两种方法

- containesKey 表示 record 中是否含有指定 key
- [key] 表示返回 record 中 key 对应的类型

特别地，对于 record 类型的乘法，这里假设如果有 key 相同会直接返回错误，翻译里就不做判断了
